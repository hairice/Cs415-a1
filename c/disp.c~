/* disp.c : dispatcher
 */

#include <xeroskernel.h>

void initializeProcessQueue();
void initializeReadyQueue();
void initializeStoppedQueue();
void dispatch();
void syscreate();
void sysstop();
void sysyield();
<<<<<<< HEAD
void ready(struct pcb*);
struct pcb* next();
void cleanup(struct pcb*);
void printPcbData(char*, struct pcb*);
void insertNodeAtEndOfQueue(struct pcb* node, struct pcb* queueBeginning);
=======
void create();
void ready(struct pcb*);
struct pcb* next();
void cleanup(struct pcb*);
void printPcbData(char*, struct processQueueNode*);
>>>>>>> 8bd172adfdc050abc6178022fff84273c218f0cd


/* Your code goes here */

static struct pcb* currentProcess;
<<<<<<< HEAD
static struct pcb* readyQueue;
static struct pcb* freeQueue;
static struct pcb* pcbTable[31];
=======
static struct processQueueNode* readyQueueBeginning;
static struct processQueueNode* stoppedQueue;
static struct processQueueNode* pcbTable[0];


struct pcb {
	int pid;
	int state;
	int priority;
};

struct processQueueNode {
	struct processQueueNode* prev;
	struct processQueueNode* next;
	struct pcb* process;
};
>>>>>>> 8bd172adfdc050abc6178022fff84273c218f0cd


/**
	Initializes the process ready queue
*/
void initializeProcessQueue() { 
<<<<<<< HEAD
	initializeProcesses();
=======
	initializeReadyQueue();	
	initializeStoppedQueue();
}

void initializeReadyQueue() {
	struct processQueueNode* queueNode = kmalloc(sizeof(struct processQueueNode));
	struct pcb* process = kmalloc(sizeof(struct pcb));
	
	process->state = READY;
	queueNode->process = process;
	queueNode->next = queueNode;
	queueNode->prev = queueNode;

	readyQueueBeginning = queueNode;
	pcbTable[0] = readyQueueBeginning;
	
	printPcbData("queue", readyQueueBeginning);
}

void initializeStoppedQueue() {
	struct processQueueNode* queueNode = kmalloc(sizeof(struct processQueueNode));
		
	queueNode->next = queueNode;
	queueNode->prev = queueNode;
	queueNode->process = 0;
	stoppedQueue = queueNode;
>>>>>>> 8bd172adfdc050abc6178022fff84273c218f0cd
}

void initializeProcesses() {
	pcbTable[0] = kmalloc(sizeof(struct pcb));
	pcbTable[0]->next = pcbTable[0];
	pcbTable[0]->prev = pcbTable[0];
	freeQueue = pcbTable[0];
	int i;
	for (i = 1; i < 32; i++) {
		pcbTable[i] = kmalloc(sizeof(struct pcb));
		insertNodeAtEndOfQueue(pcbTable[i], freeQueue);
	}
}

void dispatch() { 
	struct pcb* process = next();
	for( ;; ) {
		//short request = contextswitch( process );
		short request = CREATE;
		switch(request) {
<<<<<<< HEAD
			case(CREATE): create(currentProcess, 16); break;
=======
			case(CREATE): create(); break;
>>>>>>> 8bd172adfdc050abc6178022fff84273c218f0cd
			case(YIELD): ready(process); process = next(); break;
			case(STOP): cleanup(process); process = next(); break;
		}
	}
}

/**
	Removes the next process from the ready queue and 
	returns an index or a pointer to its process control block
*/
struct pcb* next() {
<<<<<<< HEAD
	struct pcb* process = readyQueue;
	kprintf("\n------ DISPATCH NEXT ------\n");
	kprintf("\nreadyQueue1: %d; readyQueue next: %d\n", readyQueue, readyQueue->next);
=======
	struct pcb* process = readyQueueBeginning->process;
	kprintf("\n------ DISPATCH NEXT ------\n");
	kprintf("\nreadyQueueBeginning1: %d; readyQueueBeginning next: %d\n", readyQueueBeginning, readyQueueBeginning->next);
>>>>>>> 8bd172adfdc050abc6178022fff84273c218f0cd
	
	readyQueue = readyQueue->next;
	return process;
}

<<<<<<< HEAD
/**
	Takes an index or pointer to a process control block and 
	adds it to the ready queue
*/
void ready(struct pcb* process) {
	printPcbData("queue", readyQueue);
	insertNodeAtEndOfQueue(process, readyQueue);

	//printPcbData("queue", readyQueue);
	//printPcbData("new", newQueueNode);
}

void cleanup(struct pcb* process) {
	kfree(process->stack);
	insertNodeAtEndOfQueue(process, freeQueue);
}

void syscreate() {
	
}

void sysstop() {

}

void sysyield() {
	
=======
void create() {
	//kprintf("\nCreating new process\n");
	struct pcb* process = kmalloc(sizeof(struct pcb));
	
	ready(process);
}

/**
	Takes an index or pointer to a process control block and 
	adds it to the ready queue
*/
void ready(struct pcb* process) {
	struct processQueueNode* newQueueNode = kmalloc(sizeof(struct processQueueNode));
	
	process->state = READY;
	newQueueNode->process = process;

	printPcbData("queue", readyQueueBeginning);

	insertNodeAtEndOfQueue(newQueueNode, readyQueueBeginning);

	//printPcbData("queue", readyQueueBeginning);
	//printPcbData("new", newQueueNode);
}

void cleanup(struct pcb* process) {
	process->state = STOPPED;
	if (!stoppedQueue->process) {
		stoppedQueue->process = process;
	} else {
		struct processQueueNode* queueNode;
		queueNode->process = process;
		insertNodeAtEndOfQueue(queueNode, stoppedQueue);
	}
}

void syscreate() {
	
}

void sysstop() {

}

void sysyield() {
	
>>>>>>> 8bd172adfdc050abc6178022fff84273c218f0cd
}



<<<<<<< HEAD
void insertNodeAtEndOfQueue(struct pcb* node, struct pcb* queueBeginning) {
	struct pcb* finalQueueNode = queueBeginning->prev;
=======
void insertNodeAtEndOfQueue(struct processQueueNode* node, struct processQueueNode* queueBeginning) {
	struct processQueueNode* finalQueueNode = queueBeginning->prev;
>>>>>>> 8bd172adfdc050abc6178022fff84273c218f0cd
	node->next = queueBeginning;
	node->prev = finalQueueNode;
	finalQueueNode->next = node;
	queueBeginning->prev = node;
}

<<<<<<< HEAD
void printPcbData(char* info, struct pcb* node) {
	kprintf("%s pcb: %d, ->prev: %d, ->next: %d, ->stackSize: %d\n", info,
		&node, node->prev, node->next, node->stack->size);
=======
void printPcbData(char* info, struct processQueueNode* node) {
	kprintf("%s pcb: %d, ->prev: %d, ->next: %d, ->state: %d\n", info,
		&node, node->prev, node->next, node->process->state);
>>>>>>> 8bd172adfdc050abc6178022fff84273c218f0cd
}
